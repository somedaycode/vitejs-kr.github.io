import{o as n,c as s,a as e}from"./app.25729eba.js";const a='{"title":"Server-Side Rendering","description":"","frontmatter":{},"headers":[{"level":2,"title":"Example Projects","slug":"example-projects"},{"level":2,"title":"Source Structure","slug":"source-structure"},{"level":2,"title":"Conditional Logic","slug":"conditional-logic"},{"level":2,"title":"Setting Up the Dev Server","slug":"setting-up-the-dev-server"},{"level":2,"title":"Building for Production","slug":"building-for-production"},{"level":2,"title":"Generating Preload Directives","slug":"generating-preload-directives"},{"level":2,"title":"Pre-Rendering / SSG","slug":"pre-rendering-ssg"},{"level":2,"title":"SSR Externals","slug":"ssr-externals"},{"level":2,"title":"SSR-specific Plugin Logic","slug":"ssr-specific-plugin-logic"}],"relativePath":"guide/ssr.md","lastUpdated":1621314204074}',t={},o=e('<h1 id="server-side-rendering"><a class="header-anchor" href="#server-side-rendering" aria-hidden="true">#</a> Server-Side Rendering</h1><div class="warning custom-block"><p class="custom-block-title">Experimental</p><p>SSR support is still experimental and you may encounter bugs and unsupported use cases. Proceed at your own risk.</p></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>SSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. If you are looking for integration with traditional server-side frameworks, check out the <a href="./backend-integration.html">Backend Integration guide</a> instead.</p><p>The following guide also assumes prior experience working with SSR in your framework of choice, and will only focus on Vite-specific integration details.</p></div><div class="tip custom-block"><p class="custom-block-title">Help</p><p>If you have questions, the community is usually helpful at <a href="https://discord.gg/PkbxgzPhJv" target="_blank" rel="noopener noreferrer">Vite Discord&#39;s #ssr channel</a>.</p></div><h2 id="example-projects"><a class="header-anchor" href="#example-projects" aria-hidden="true">#</a> Example Projects</h2><p>Vite provides built-in support for server-side rendering (SSR). The Vite playground contains example SSR setups for Vue 3 and React, which can be used as references for this guide:</p><ul><li><a href="https://github.com/vitejs/vite/tree/main/packages/playground/ssr-vue" target="_blank" rel="noopener noreferrer">Vue 3</a></li><li><a href="https://github.com/vitejs/vite/tree/main/packages/playground/ssr-react" target="_blank" rel="noopener noreferrer">React</a></li></ul><h2 id="source-structure"><a class="header-anchor" href="#source-structure" aria-hidden="true">#</a> Source Structure</h2><p>A typical SSR application will have the following source file structure:</p><div class="language-"><pre><code>- index.html\n- src/\n  - main.js          # exports env-agnostic (universal) app code\n  - entry-client.js  # mounts the app to a DOM element\n  - entry-server.js  # renders the app using the framework&#39;s SSR API\n</code></pre></div><p>The <code>index.html</code> will need to reference <code>entry-client.js</code> and include a placeholder where the server-rendered markup should be injected:</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--ssr-outlet--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/src/entry-client.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><p>You can use any placeholder you prefer instead of <code>&lt;!--ssr-outlet--&gt;</code>, as long as it can be precisely replaced.</p><h2 id="conditional-logic"><a class="header-anchor" href="#conditional-logic" aria-hidden="true">#</a> Conditional Logic</h2><p>If you need to perform conditional logic based on SSR vs. client, you can use</p><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">SSR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ... server only logic</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>This is statically replaced during build so it will allow tree-shaking of unused branches.</p><h2 id="setting-up-the-dev-server"><a class="header-anchor" href="#setting-up-the-dev-server" aria-hidden="true">#</a> Setting Up the Dev Server</h2><p>When building an SSR app, you likely want to have full control over your main server and decouple Vite from the production environment. It is therefore recommended to use Vite in middleware mode. Here is an example with <a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer">express</a>:</p><p><strong>server.js</strong></p><div class="language-js"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br></div><pre><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;path&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;express&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span> createServer<span class="token operator">:</span> createViteServer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;vite&#39;</span><span class="token punctuation">)</span>\n\n<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n  <span class="token comment">// Create vite server in middleware mode. This disables Vite&#39;s own HTML</span>\n  <span class="token comment">// serving logic and let the parent server take control.</span>\n  <span class="token keyword">const</span> vite <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">createViteServer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    server<span class="token operator">:</span> <span class="token punctuation">{</span> middlewareMode<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token comment">// use vite&#39;s connect instance as middleware</span>\n  app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>vite<span class="token punctuation">.</span>middlewares<span class="token punctuation">)</span>\n\n  app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">&#39;*&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// serve index.html - we will tackle this next</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>Here <code>vite</code> is an instance of <a href="./api-javascript.html#vitedevserver">ViteDevServer</a>. <code>vite.middlewares</code> is a <a href="https://github.com/senchalabs/connect" target="_blank" rel="noopener noreferrer">Connect</a> instance which can be used as a middleware in any connect-compatible Node.js framework.</p><p>The next step is implementing the <code>*</code> handler to serve server-rendered HTML:</p><div class="language-js"><pre><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">&#39;*&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> url <span class="token operator">=</span> req<span class="token punctuation">.</span>originalUrl\n\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 1. Read index.html</span>\n    <span class="token keyword">let</span> template <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>\n      path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;index.html&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token string">&#39;utf-8&#39;</span>\n    <span class="token punctuation">)</span>\n\n    <span class="token comment">// 2. Apply vite HTML transforms. This injects the vite HMR client, and</span>\n    <span class="token comment">//    also applies HTML transforms from Vite plugins, e.g. global preambles</span>\n    <span class="token comment">//    from @vitejs/plugin-react-refresh</span>\n    template <span class="token operator">=</span> <span class="token keyword">await</span> vite<span class="token punctuation">.</span><span class="token function">transformIndexHtml</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> template<span class="token punctuation">)</span>\n\n    <span class="token comment">// 3. Load the server entry. vite.ssrLoadModule automatically transforms</span>\n    <span class="token comment">//    your ESM source code to be usable in Node.js! There is no bundling</span>\n    <span class="token comment">//    required, and provides efficient invalidation similar to HMR.</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> vite<span class="token punctuation">.</span><span class="token function">ssrLoadModule</span><span class="token punctuation">(</span><span class="token string">&#39;/src/entry-server.js&#39;</span><span class="token punctuation">)</span>\n\n    <span class="token comment">// 4. render the app HTML. This assumes entry-server.js&#39;s exported `render`</span>\n    <span class="token comment">//    function calls appropriate framework SSR APIs,</span>\n    <span class="token comment">//    e.g. ReactDOMServer.renderToString()</span>\n    <span class="token keyword">const</span> appHtml <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">render</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>\n\n    <span class="token comment">// 5. Inject the app-rendered HTML into the template.</span>\n    <span class="token keyword">const</span> html <span class="token operator">=</span> template<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;!--ssr-outlet--&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> appHtml<span class="token punctuation">)</span>\n\n    <span class="token comment">// 6. Send the rendered HTML back.</span>\n    res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">&#39;Content-Type&#39;</span><span class="token operator">:</span> <span class="token string">&#39;text/html&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// If an error is caught, let vite fix the stracktrace so it maps back to</span>\n    <span class="token comment">// your actual source code.</span>\n    vite<span class="token punctuation">.</span><span class="token function">ssrFixStacktrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n    res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>The <code>dev</code> script in <code>package.json</code> should also be changed to use the server script instead:</p><div class="language-diff"><pre><code><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> &quot;scripts&quot;: {\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   &quot;dev&quot;: &quot;vite&quot;\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   &quot;dev&quot;: &quot;node server&quot;\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }\n</span></span></code></pre></div><h2 id="building-for-production"><a class="header-anchor" href="#building-for-production" aria-hidden="true">#</a> Building for Production</h2><p>To ship an SSR project for production, we need to:</p><ol><li>Produce a client build as normal;</li><li>Produce an SSR build, which can be directly loaded via <code>require()</code> so that we don&#39;t have to go through Vite&#39;s <code>ssrLoadModule</code>;</li></ol><p>Our scripts in <code>package.json</code> will look like this:</p><div class="language-json"><pre><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;dev&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node server&quot;</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;build:client&quot;</span><span class="token operator">:</span> <span class="token string">&quot;vite build --outDir dist/client&quot;</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;build:server&quot;</span><span class="token operator">:</span> <span class="token string">&quot;vite build --outDir dist/server --ssr src/entry-server.js &quot;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>Note the <code>--ssr</code> flag which indicates this is an SSR build. It should also specify the SSR entry.</p><p>Then, in <code>server.js</code> we need to add some production specific logic by checking <code>process.<wbr>env.NODE_ENV</code>:</p><ul><li><p>Instead of reading the root <code>index.html</code>, use the <code>dist/client/index.html</code> as the template instead, since it contains the correct asset links to the client build.</p></li><li><p>Instead of <code>await vite.ssrLoadModule(&#39;/src/entry-server.js&#39;)</code>, use <code>require(&#39;./dist/server/entry-server.js&#39;)</code> instead (this file is the result of the SSR build).</p></li><li><p>Move the creation and all usage of the <code>vite</code> dev server behind dev-only conditional branches, then add static file serving middlewares to serve files from <code>dist/client</code>.</p></li></ul><p>Refer to the <a href="https://github.com/vitejs/vite/tree/main/packages/playground/ssr-vue" target="_blank" rel="noopener noreferrer">Vue</a> and <a href="https://github.com/vitejs/vite/tree/main/packages/playground/ssr-react" target="_blank" rel="noopener noreferrer">React</a> demos for working setup.</p><h2 id="generating-preload-directives"><a class="header-anchor" href="#generating-preload-directives" aria-hidden="true">#</a> Generating Preload Directives</h2><p><code>vite build</code> supports the <code>--ssrManifest</code> flag which will generate <code>ssr-manifest.json</code> in build output directory:</p><div class="language-diff"><pre><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> &quot;build:client&quot;: &quot;vite build --outDir dist/client&quot;,\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> &quot;build:client&quot;: &quot;vite build --outDir dist/client --ssrManifest&quot;,\n</span></span></code></pre></div><p>The above script will now generate <code>dist/client/ssr-manifest.json</code> for the client build (Yes, the SSR manifest is generated from the client build because we want to map module IDs to client files). The manifest contains mappings of module IDs to their associated chunks and asset files.</p><p>To leverage the manifest, frameworks need to provide a way to collect the module IDs of the components that were used during a server render call.</p><p><code>@vitejs/plugin-vue</code> supports this out of the box and automatically registers used component module IDs on to the associated Vue SSR context:</p><div class="language-js"><pre><code><span class="token comment">// src/entry-server.js</span>\n<span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token keyword">await</span> vueServerRenderer<span class="token punctuation">.</span><span class="token function">renderToString</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>\n<span class="token comment">// ctx.modules is now a Set of module IDs that were used during the render</span>\n</code></pre></div><p>In the production branch of <code>server.js</code> we need to read and pass the manifest to the <code>render</code> function exported by <code>src/entry-server.js</code>. This would provide us with enough information to render preload directives for files used by async routes! See <a href="https://github.com/vitejs/vite/blob/main/packages/playground/ssr-vue/src/entry-server.js" target="_blank" rel="noopener noreferrer">demo source</a> for full example.</p><h2 id="pre-rendering-ssg"><a class="header-anchor" href="#pre-rendering-ssg" aria-hidden="true">#</a> Pre-Rendering / SSG</h2><p>If the routes and the data needed for certain routes are known ahead of time, we can pre-render these routes into static HTML using the same logic as production SSR. This can also be considered a form of Static-Site Generation (SSG). See <a href="https://github.com/vitejs/vite/blob/main/packages/playground/ssr-vue/prerender.js" target="_blank" rel="noopener noreferrer">demo pre-render script</a> for working example.</p><h2 id="ssr-externals"><a class="header-anchor" href="#ssr-externals" aria-hidden="true">#</a> SSR Externals</h2><p>Many dependencies ship both ESM and CommonJS files. When running SSR, a dependency that provides CommonJS builds can be &quot;externalized&quot; from Vite&#39;s SSR transform / module system to speed up both dev and build. For example, instead of pulling in the pre-bundled ESM version of React and then transforming it back to be Node.js-compatible, it is more efficient to simply <code>require(&#39;react&#39;)</code> instead. It also greatly improves the speed of the SSR bundle build.</p><p>Vite performs automated SSR externalization based on the following heuristics:</p><ul><li><p>If a dependency&#39;s resolved ESM entry point and its default Node entry point are different, its default Node entry is probably a CommonJS build that can be externalized. For example, <code>vue</code> will be automatically externalized because it ships both ESM and CommonJS builds.</p></li><li><p>Otherwise, Vite will check whether the package&#39;s entry point contains valid ESM syntax - if not, the package is likely CommonJS and will be externalized. As an example, <code>react-dom</code> will be automatically externalized because it only specifies a single entry which is in CommonJS format.</p></li></ul><p>If this heuristics leads to errors, you can manually adjust SSR externals using <code>ssr.external</code> and <code>ssr.noExternal</code> config options.</p><p>In the future, this heuristics will likely improve to detect if the project has <code>type: &quot;module&quot;</code> enabled, so that Vite can also externalize dependencies that ship Node-compatible ESM builds by importing them via dynamic <code>import()</code> during SSR.</p><div class="warning custom-block"><p class="custom-block-title">Working with Aliases</p><p>If you have configured aliases that redirects one package to another, you may want to alias the actual <code>node_modules</code> packages instead to make it work for SSR externalized dependencies. Both <a href="https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias" target="_blank" rel="noopener noreferrer">Yarn</a> and <a href="https://pnpm.js.org/en/aliases" target="_blank" rel="noopener noreferrer">pnpm</a> support aliasing via the <code>npm:</code> prefix.</p></div><h2 id="ssr-specific-plugin-logic"><a class="header-anchor" href="#ssr-specific-plugin-logic" aria-hidden="true">#</a> SSR-specific Plugin Logic</h2><p>Some frameworks such as Vue or Svelte compiles components into different formats based on client vs. SSR. To support conditional transforms, Vite passes an additional <code>ssr</code> argument to the following plugin hooks:</p><ul><li><code>resolveId</code></li><li><code>load</code></li><li><code>transform</code></li></ul><p><strong>Example:</strong></p><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mySSRPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;my-ssr&#39;</span><span class="token punctuation">,</span>\n    <span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> id<span class="token punctuation">,</span> ssr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>ssr<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// perform ssr-specific transform...</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div>',57);t.render=function(e,a,t,p,c,r){return n(),s("div",null,[o])};export default t;export{a as __pageData};
